# 基础
---
##### npm依赖于Node.js
# 常用命令
---

##### 锁文件
- `echo 'package-lock=false' >> .npmrc`在包中禁用锁文件
##### 下载与更新
`npm install [包名]@[版本]` `-g` 在全局安装 `install`可以简写为`i`
`npm init -y`初始化项目 -y 或者--yes 是使用默认值，后期可以在package.json中修改
`npm uninstall [包名]`卸载
`npm update [包名]`更新

在npm中，包（package）、模块（module）、依赖（dependency）说的都是一回事儿。
- `npm init` 初始化项目，其实就是创建一个`package.json`文件。
- `npm install` 安装所有项目依赖。
- `npm help xxx` 查看`xxx`命令的帮助信息。

##### `npm search` 搜索（快捷方式：`find`, `s`）
- `xxx` 搜索`xxx` 如：`npm search jquery`。

##### `npm install` 安装 （快捷方式：`i`）

- `xxx` 搜索并安装xxx（局部）。安装多个依赖可用空格分割，如`npm i jquery bootstrap`。
- `xxx -g` 搜索并安装xxx（全局）。安装多个同上。
- `xxx -D` 安装并将依赖信息写在`package.json`中的`devDependencies`中。
- 快捷方式 `i`均可，如`npm i jquery`。
- `xxx@版本号` 指定需要安装的版本号，若不指定将安装最新的稳定版本。

##### `npm uninstall` 卸载（快捷方式：`rm`, `r`）
- `xxx` 卸载xxx。多个依赖可用空格分割。
- `xxx -D` 卸载xxx，并将依赖信息从`package.json`中的`devDependencies`中清除。

##### `npm list` 列出已安装依赖（快捷方式：`ls`）
- 默认列出局部依赖。
- `npm list -g` 列出已安装的全局依赖。

##### `npm outdated` 检查过期依赖

##### `npm update` 更新依赖（快捷方式：`up`）
- `xxx` 局部更新xxx。
- `xxx -g` 全局更新xxx。

##### `npm root` 查看依赖安装路径（也就是`node_modules`的路径）
- 默认查看局部安装路径。
- `-g` 查看全局安装路径。

##### `npm view` 查看模块的注册信息
- `xxx versions` 列出`xxx`的所有版本， 如：`npm view jquery versions`。
- `xxx dependencies` 列出`xxx`的所有依赖， 如：`npm view gulp dependencies`。

##### package.json
![[Pasted image 20250908165423.png]]
生产与开发环境

好的，这两个符号是 **npm** 的**语义化版本控制（SemVer）** 中非常重要的部分，它们定义了你的项目可以接受依赖包的哪些更新。

首先，一个版本号通常格式为：**`主版本号.次版本号.修订号`** （`major.minor.patch`），例如 `4.18.2`。
*   **主版本号 (Major)**：做了**不兼容的 API 修改**（ Breaking Changes ）。大升级，可能用不了。
*   **次版本号 (Minor)**：做了**向下兼容的功能性新增**。新功能，但不会破坏老代码。
*   **修订号 (Patch)**：做了**向下兼容的问题修正**。修 Bug，最安全。

`^` 和 `~` 的作用就是用来定义允许自动获取哪个级别的更新。

---

### 1. 插入符号 (Caret) - `^`

*   **含义**：允许接受**不改变版本号中第一个非零数字**的更新。通俗讲，就是允许**次版本号和修订号**的更新，但**不允许主版本号**的更新。
*   **规则**：它非常智能，会根据你指定的版本号来灵活判断：
    *   **如果主版本号不是 `0`** (即 `>=1.0.0`)：
        `^4.18.0` → **允许** `4.18.1`, `4.19.0`, 但不能是 `5.0.0`。
        （因为第一个非零数字是 `4`，即主版本号，所以它被锁定，允许 minor 和 patch 更新）。
    *   **如果主版本号是 `0`** (即 `0.x.x`)，则看次版本号：
        `^0.2.3` → **允许** `0.2.4`, `0.2.5`, 但不能是 `0.3.0` 或 `1.0.0`。
        （因为 `0` 是主版本号，第一个非零数字是 `2`，即次版本号，所以它被锁定，只允许 patch 更新）。
    *   **如果主版本和次版本都是 `0`**：
        `^0.0.3` → **只允许**修订号的更新，即只能是 `0.0.3` 或 `0.0.4`，不能是 `0.1.0`。
        （因为第一个非零数字是 `3`，即修订号）。

*   **这是 `npm install <package>` 的默认行为**，也是最常用的符号。它允许你自动获取安全更新和新功能，同时避免破坏性变更。

---

### 2. 波浪符号 (Tilde) - `~`

*   **含义**：允许接受**修订号**的更新，但通常**不允许次版本号**的更新。比 `^` 更严格。
*   **规则**：
    *   `~4.18.0` → **允许** `4.18.1`, `4.18.2`, 但不能是 `4.19.0`。
    *   `~4.18.3` → **允许** `4.18.4`, `4.18.5`, 但不能是 `4.19.0`。
    *   如果指定了次版本号，但修订号省略（被当作 `0`）：
        `~4.18` → 等同于 `~4.18.0` （允许 `4.18.x`）
    *   如果只指定了主版本号：
        `~4` → 等同于 `~4.0.0` （允许 `4.0.x`，但很奇怪，因为 `4` 通常会被解析为 `^4.0.0`）

*   **使用场景**：当你希望**只接受错误修复（Bug fixes）**，而对任何新功能都持保守态度时使用。这在追求极度稳定的生产环境中可能有用，但现在更常见的做法是使用 `^` 并结合 `package-lock.json` 来锁定。

---

### 对比总结与示例

| 符号 | 示例写法 | 允许的更新范围 (示例) | 说明 |
| :--- | :--- | :--- | :--- |
| **`^`** (Caret) | `^4.18.0` | `>=4.18.0` **且** `<5.0.0` | **默认推荐**。允许新功能和Bug修复，但禁止大版本更新。 |
| **`~`** (Tilde) | `~4.18.0` | `>=4.18.0` **且** `<4.19.0` | 更严格。通常只允许Bug修复。 |
| **(无前缀)** | `4.18.0` | **严格等于** `4.18.0` | 完全锁定版本，不接受任何更新。 |

### 为什么这些符号需要 `package-lock.json`？

这正是 `package-lock.json` 存在的核心原因。

你的 `package.json` 里写的是 `^4.18.0`（一个**范围**），但你需要确保团队和服务器安装的**确切是同一个版本**（比如 `4.18.2`）。

`package-lock.json` 的作用就是把这个**灵活的范围** **锁定** 为一个**精确的版本**，记录下你最后一次安装时实际得到的版本 `4.18.2` 以及它的所有依赖树。这样，无论你什么时候再次安装，得到的都是完全一致的结果，从而保证了依赖环境的绝对一致。

**简单比喻：**
*   `package.json` (`^4.18.0`)： “我想要一杯大杯的拿铁。”
*   `package-lock.json` (`4.18.2`)： “这是你2023年10月27日下午3点收到的那杯**具体**的大杯拿铁的所有成分和比例清单（咖啡豆批次、牛奶毫升数、咖啡因含量等）。下次必须严格按照这个清单做。”

所以，在现代开发中，你应该始终使用 `^`（享受语义化版本的好处），并**将 `package-lock.json` 提交到 Git**（享受确定性带来的稳定）。