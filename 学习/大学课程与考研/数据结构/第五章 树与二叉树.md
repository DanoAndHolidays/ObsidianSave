# 5.1 树
## 5.1.1 树的定义
![[Pasted image 20251109182350.png]]
## 5.1.2 基本术语
路径是有向边
![[Pasted image 20251109182755.png]]

![[Pasted image 20251109183049.png]]
### 有序数与无序树
![[Pasted image 20251109183153.png]]
### 森林
![[Pasted image 20251109183250.png]]
## 5.1.3 树的性质
除了根结点，每个结点都有一个入度
![[Pasted image 20251109183415.png]]

![[Pasted image 20251109183625.png]]

![[Pasted image 20251109183736.png]]
![[Pasted image 20251109183826.png]]
![[Pasted image 20251109183906.png]]

![[Pasted image 20251109184142.png]]
![[Pasted image 20251109184206.png]]
# 5.2  二叉树
## 5.2.1 基本概念
![[Pasted image 20251109184434.png]]
### 满二叉树与完全二叉树
![[Pasted image 20251109184905.png]]
### 二叉排序树
![[Pasted image 20251109185116.png]]
### 平衡二叉树
![[Pasted image 20251109185231.png]]
## 5.2.2 二叉树的性质

![[Pasted image 20251109185556.png]]

![[Pasted image 20251109185612.png]]

![[Pasted image 20251109185701.png]]

![[Pasted image 20251109185910.png]]
![[Pasted image 20251109190029.png]]

![[Pasted image 20251109190234.png]]
## 5.2.3 二叉树的存储结构
### 顺序存储
![[Pasted image 20251109190604.png]]

![[Pasted image 20251109190727.png]]
使用顺序存储二叉树来存储，只适合完全二叉树，会有大量空位：
![[Pasted image 20251109191037.png]]
### 链式存储
n个结点，有n-1个指针指向结点（根结点没有），每个结点有两个指针域，共有2n个，剩余的n+1个指针域为null：
![[Pasted image 20251109191235.png]]

代码实现：
![[Pasted image 20251109191628.png]]
# 5.3  二叉树的遍历
## 5.3.1 先中后序遍历（深度优先）
![[Pasted image 20251109192415.png]]
![[Pasted image 20251109192650.png]]
### 代码实现
调整visit()的位置就可以实现不同的算法：
![[Pasted image 20251109192802.png]]

先序是第一次访问的结点，中序是第二次访问的结点：
![[Pasted image 20251109193230.png]]
### 求深度
![[Pasted image 20251109193539.png]]
## 5.3.2 层次遍历（广度优先）
![[Pasted image 20251109193800.png]]
### 代码实现
![[Pasted image 20251109194027.png]]
保存指针即可，可以减小空间消耗
## 5.3.3 遍历序列构造二叉树
只依靠一种遍历序列不可能构造出唯一的二叉树结构，至少两种且必须包括中序：

![[Pasted image 20251109195252.png]]
### 先序与中序
![[Pasted image 20251109195701.png]]
![[Pasted image 20251109195748.png]]
![[Pasted image 20251109195811.png]]
### 后序与中序
原理与先序一样
### 层次与中序
![[Pasted image 20251109200220.png]]
## 5.3.4 线索二叉树
在普通的二叉树中去通过一个非根结点去遍历或寻找它的前驱与后继是很困难的
### 中序线索二叉树
![[Pasted image 20251109201735.png]]
### 先、后序线索二叉树
原理与中序一样
### 存储结构
![[Pasted image 20251109202007.png]]

![[Pasted image 20251109202033.png]]
### 代码实现
中序线索化：
![[Pasted image 20251109203009.png]]

另一种实现方式：
![[Pasted image 20251109204300.png]]
前序和后序调整visit()的代码顺序即可，但是注意在先序线索化的时候要判断某个结点的左孩子是否为线索化的前驱，这样会有循环问题，后序没有这个问题。
![[Pasted image 20251109203809.png]]