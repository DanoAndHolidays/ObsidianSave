# 7.1 查找的基本概念
![[Pasted image 20251030214257.png]]
查找表并不是指某一种特定的数据结构，而是被查找的数据的一个称呼
- 静态查找表：仅查找
- 动态查找表：查找、插入与删除

![[Pasted image 20251030214806.png]]
# 7.2 顺序与折半查找
## 7.2.1 顺序查找（线性查找）
从头找到尾
![[Pasted image 20251030215557.png]]

添加哨兵：
![[Pasted image 20251030215857.png]]

![[Pasted image 20251030220154.png]]
### 使用顺序表优化
![[Pasted image 20251030220626.png]]
## 7.2.2 二分查找（折半查找）
仅适用于有序顺序表，链表是不可能实现折半的
![[Pasted image 20251030221453.png]]
![[Pasted image 20251030221622.png]]
![[Pasted image 20251030221734.png]]
![[Pasted image 20251030221820.png]]

![[Pasted image 20251030222420.png]]
### 代码实现
![[Pasted image 20251030222643.png]]
### 效率分析（判定树）
![[Pasted image 20251030223107.png]]
![[Pasted image 20251030223718.png]]

![[Pasted image 20251030223516.png]]
![[Pasted image 20251030223548.png]]

![[Pasted image 20251030223833.png]]
## 7.2.3 分块查找（索引顺序查找）
使用存储着每个区间最大值的索引表

![[Pasted image 20251031160146.png]]
![[Pasted image 20251031160326.png]]

可以结合折半查找，在这里就和普通的折半查找不同。
![[Pasted image 20251031161419.png]]
 移动后是这样的，正常应该是结束查找。但是应在low中查找。
 ![[Pasted image 20251031161111.png]]
 
![[Pasted image 20251031161953.png]]
### ASL分析
在索引表顺序查找的情况下：手动模拟一遍就行
在索引表折半查找的情况下：同上，但是注意折半的规律
对于查找失败的情况更加复杂，一般不考

但是，查找表分块有规律：
![[Pasted image 20251031163039.png]]

![[Pasted image 20251031163148.png]]

# 7.3 树型查找
### 7.3.1 二叉排序树（BST）![[Pasted image 20251031170102.png]]
![[Pasted image 20251031170310.png]]
![[Pasted image 20251031170341.png]]
### 查找
递归的实现方式会导致每一次递归在函数调用栈中新增一个任务，这导致O(h)的空间复杂度。
![[Pasted image 20251031170454.png]]
### 插入
递归实现：
![[Pasted image 20251031170929.png]]
### 构造
![[Pasted image 20251031171122.png]]
### 删除
1. 叶子结点：直接删除
2. 只有左或右子树：使用其子树代替
![[Pasted image 20251031172227.png]]
3. 同时具有左子树右子树：将左子树中的最大值（右子树中的最小值）取出，作为代替结点，被取出的结点的视为被删除，使用操作2.
![[Pasted image 20251031172515.png]]
### ASL
- 成功：时间复杂度O(h)，应该尽可能的保证树的高度最低（平衡）
![[Pasted image 20251031172552.png]]
（1 * 1+2 * 2+3 * 4+4 * 1）/8=2.625

- 失败：
![[Pasted image 20251031172824.png]]
### 7.3.2 平衡二叉树（AVL）
树上的任意结点的平衡因子（左子树高 - 右子树高）为-1、0、1。也就是，左右子树的高度不能超过1
![[Pasted image 20251031173248.png]]

### 插入后调整树结构
每次调整最小不平衡子树，调整完毕后，其余的节点的平衡因子会自动的恢复正常：
![[Pasted image 20251031173643.png]]

调整分为四种情况：
1. LL：在结点的左孩子的左子树中插入导致不平衡
![[Pasted image 20251031174534.png]]
这里的所有子树的高度均为H，是因为只有在这种情况下插入节点才会导致A树成为最小不平衡子树。

2. RR：在结点的右孩子的右子树中插入导致不平衡
![[Pasted image 20251031174932.png]]


3. LR：在结点的左孩子的右子树中插入导致不平衡
![[Pasted image 20251031175603.png]]
无论是插进入C的左边还是右边，都先C左旋，再将C右旋
![[Pasted image 20251031175746.png]]

其实不必一步步旋转，可以看做是对60结点的一个“提升”
![[Pasted image 20251031180945.png]]

4. RL：在结点的右孩子的左子树中插入导致不平衡
![[Pasted image 20251031180022.png]]


### 代码实现
![[Pasted image 20251031175215.png]]
### ASL
![[Pasted image 20251031181400.png]]
### 删除
时间复杂度：O(log n)
1. 删除结点，与二叉树一样。
2. 向上寻找到最小不平衡子树，找不到就结束。
3. 寻找最小不平衡子树根节的最高点子树，在此子树上重复一次操作，也就是找到个头最高的儿子，与这个儿子的最高的孙子。若果左右儿子、与左右孙子一样，可以随便选一个，结果一样。（在考试中，不可能考多可能性的）
4. 根据孙子与祖先的位置关系，对儿子按LL、RR、RL与LR进行旋转，与插入的操作一样。
![[Pasted image 20251031191633.png]]
![[Pasted image 20251031191812.png]]
5. 如果有不平衡的现象，重复2操作。（408考察可能性较低）
![[Pasted image 20251031192250.png]]
发生了不平衡传到：
![[Pasted image 20251031192330.png]]
重复步骤2：
![[Pasted image 20251031192456.png]]
![[Pasted image 20251031192537.png]]
不平衡传导结束，算法结束。
### 7.3.3 红黑树（RBT）
在平衡二叉树（AVL）中进行删除操作，可能会破坏平衡，需要频繁地进行树的形态调整，时间开销大。
而红黑树（RBT），很多时候不会被破坏平衡性，就算需要调整，也可以在常数级的时间内完成。

在经常查询的场景可以使用平衡二叉树，在频繁删除插入的场景使用红黑树。在现代开发过程中，最常使用RBT。

RBT本身是一种优化的BST
![[Pasted image 20251031195713.png]]
左根右，根叶黑，不红红，黑路同
![[Pasted image 20251031195820.png]]
### 性质
1. 从根节点到叶结点的最长路径不大于最短路径的2倍
2. 内部有n个节点的RBT的高度h<=2log（n+1）
![[Pasted image 20251031201608.png]]
黑高h，内部结点至少有2^h -1 个
![[Pasted image 20251031210923.png]]
树高h，根结点黑高>=h/2，此时内部最少的结点数为h^(h/2) - 1，也就是n>=h^(h/2) - 1得到h<=2log（n+1）
### 查找
与BST相同
### 插入
![[Pasted image 20251031204108.png]]

例子：每次插入不会破坏左根右，根叶黑与黑路同，但只要有不红红，就要调整树的结构。
![[Pasted image 20251031205113.png]]

![[Pasted image 20251031205437.png]]
### 删除
- 时间复杂度：O(log 2)
- 与二叉排序树相同
- 在破坏特性后，按找与插入相同的操作
# 7.4 B、B+树
## 7.4.1 B树（多路平衡查找树）
![[Pasted image 20251031212447.png]]
### 查找效率的保证
![[Pasted image 20251031213435.png]]
![[Pasted image 20251031213455.png]]
在特殊情况下，比如一个元素，根结点就可能不满足有m/2向上取整个分叉。保证树不会太高。
![[Pasted image 20251031213905.png]]
保证树的平衡

满足分叉与关键字数量、平衡要求的多叉树，就是B树。
![[Pasted image 20251031214353.png]]
![[Pasted image 20251031214544.png]]
### 特性
![[Pasted image 20251031215328.png]]
  ![[Pasted image 20251031214743.png]]
### 插入
每次插入终端结点
![[Pasted image 20251031220319.png]]

![[Pasted image 20251031220338.png]]

![[Pasted image 20251031220440.png]]
![[Pasted image 20251031220528.png]]


![[Pasted image 20251031220858.png]]

将提升的结点放置到，其父节点的分叉的后面：
![[Pasted image 20251031220741.png]]

分裂后再分裂：
![[Pasted image 20251031221308.png]]
![[Pasted image 20251031221413.png]]

![[Pasted image 20251031221138.png]]
### 删除
1. 终端结点且满足数量下限：直接删除
2. 根结点：寻找直接前驱或者直接后继代替且满足数量下限（与二叉排序树一样）。转换为了删除终端结点1操作。
3. 不满足数量下限：
	1. 借兄弟：![[Pasted image 20251031222309.png]]![[Pasted image 20251031222616.png]]
	2. 兄弟不够：![[Pasted image 20251031222758.png]]![[Pasted image 20251031222849.png]]![[Pasted image 20251031222941.png]]
## 7.4.2 B+树
与分块查找类似
![[Pasted image 20251031224111.png]]

![[Pasted image 20251031223628.png]]
这里的非叶根结点，指不是第一种情况的根节点，即不同时是叶与根的根节点。这是为了保证绝对的平衡。
### 查找
![[Pasted image 20251031224433.png]]

# 7.5 散列表