# 8.1 排序基本概念
### 稳定性
![[Pasted image 20251102185141.png]]
### 分类
![[Pasted image 20251102185109.png]]
# 8.2 插入与希尔
## 8.2.1 插入排序
![[Pasted image 20251103143724.png]]
### 代码实现
每次将大于待插入元素的前面的元素后移一位，再将待插入元素移入空出的位置：
![[Pasted image 20251103144227.png]]
空间复杂度：O(1)，时间复杂度：O(n^2)，稳定。在待排序的记录基本有序的时候，时间复杂度能达到O(1)的级别。
### 优化
在待插入元素的前面的部分是有序的，可以使用折半查找优化：
![[Pasted image 20251103145002.png]]
![[Pasted image 20251103145042.png]]
![[Pasted image 20251103145127.png]]
此时low在high的右侧，停止折半查找，high右侧的元素均大于i所指元素，low左侧则均小于。在low和high中间的位置就是待插入元素的插入位置：
![[Pasted image 20251103145257.png]]
特殊的，在这种情况下，不应该停止查找，而应该是在右侧继续寻找60，确保算法的稳定性：
![[Pasted image 20251103145651.png]]
![[Pasted image 20251103145812.png]]
这时，插入60就能够保证算法的稳定性：
![[Pasted image 20251103145845.png]]
![[Pasted image 20251103150256.png]]
## 8.2.2 希尔排序
将表中的元素拆分为多个子表，将子表中的元素排序，最后整体有序。

![[Pasted image 20251103151307.png]]
![[Pasted image 20251103151347.png]]
![[Pasted image 20251103151522.png]]
![[Pasted image 20251103151545.png]]
在这一次排序中，表中的数据就已经基本有序：
![[Pasted image 20251103151630.png]]
![[Pasted image 20251103151712.png]]
### 代码实现
![[Pasted image 20251103152435.png]]
空间复杂度：O(1)，时间复杂度：在O(n^1.3)到O(n^2)，暂时无法用数学形式证明。不稳定。并且只能基于线性表实现。
# 8.3 交换排序
## 8.3.1 冒泡排序
![[Pasted image 20251103153829.png]]
![[Pasted image 20251103153859.png]]
![[Pasted image 20251103153950.png]]
![[Pasted image 20251103154029.png]]
### 算法实现
若某一趟排序过程没有交换，就说明已经有序，可以提前结束：
![[Pasted image 20251103154257.png]]

空间复杂度：O(1)，时间复杂度：O(n^2)，稳定。
![[Pasted image 20251103154658.png]]




## 8.3.1 快速排序

