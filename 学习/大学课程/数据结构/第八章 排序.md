# 8.1 排序基本概念
### 稳定性
![[Pasted image 20251102185141.png]]
### 分类
![[Pasted image 20251102185109.png]]
# 8.2 插入与希尔
## 8.2.1 插入排序
![[Pasted image 20251103143724.png]]
### 代码实现
每次将大于待插入元素的前面的元素后移一位，再将待插入元素移入空出的位置：
![[Pasted image 20251103144227.png]]
空间复杂度：O(1)，时间复杂度：O(n^2)，稳定。在待排序的记录基本有序的时候，时间复杂度能达到O(1)的级别。
### 优化
在待插入元素的前面的部分是有序的，可以使用折半查找优化：
![[Pasted image 20251103145002.png]]
![[Pasted image 20251103145042.png]]
![[Pasted image 20251103145127.png]]
此时low在high的右侧，停止折半查找，high右侧的元素均大于i所指元素，low左侧则均小于。在low和high中间的位置就是待插入元素的插入位置：
![[Pasted image 20251103145257.png]]
特殊的，在这种情况下，不应该停止查找，而应该是在右侧继续寻找60，确保算法的稳定性：
![[Pasted image 20251103145651.png]]
![[Pasted image 20251103145812.png]]
这时，插入60就能够保证算法的稳定性：
![[Pasted image 20251103145845.png]]
![[Pasted image 20251103150256.png]]
## 8.2.2 希尔排序
将表中的元素拆分为多个子表，将子表中的元素排序，最后整体有序。

![[Pasted image 20251103151307.png]]
![[Pasted image 20251103151347.png]]
![[Pasted image 20251103151522.png]]
![[Pasted image 20251103151545.png]]
在这一次排序中，表中的数据就已经基本有序：
![[Pasted image 20251103151630.png]]
![[Pasted image 20251103151712.png]]
### 代码实现
![[Pasted image 20251103152435.png]]
空间复杂度：O(1)，时间复杂度：在O(n^1.3)到O(n^2)，暂时无法用数学形式证明。不稳定。并且只能基于线性表实现。
# 8.3 交换排序
## 8.3.1 冒泡排序
![[Pasted image 20251103153829.png]]
![[Pasted image 20251103153859.png]]
![[Pasted image 20251103153950.png]]
![[Pasted image 20251103154029.png]]
### 算法实现
若某一趟排序过程没有交换，就说明已经有序，可以提前结束：
![[Pasted image 20251103154257.png]]

空间复杂度：O(1)，时间复杂度：O(n^2)，稳定。
![[Pasted image 20251103154658.png]]
## 8.3.1 快速排序
![[Pasted image 20251103160249.png]]
![[Pasted image 20251103160517.png]]
![[Pasted image 20251103160538.png]]
![[Pasted image 20251103160556.png]]
![[Pasted image 20251103160609.png]]
![[Pasted image 20251103160626.png]]
将基准元素左右两侧的子表继续快排，直到左右子表就剩一个元素的时候
### 代码实现（重点）
![[Pasted image 20251103160903.png]]

空间复杂度：O(递归层数)，时间复杂度：O(n * 递归层数)，不稳定。递归层数的数量级在log n与n之间。理想情况下，空间复杂度：O(log n)，时间复杂度：O(nlog n)
![[Pasted image 20251103163056.png]]

对于本有序的序列，快排的性能最差。可以随机选取枢轴元素来解决这个问题。
# 8.4 选择排序
## 8.4.1 简单选择排序（暴力）
在待排序的元素中选着最小的加入有序队列
### 代码实现
![[Pasted image 20251103163815.png]]
空间复杂度：O(1)，时间复杂度：O(n^2)，不稳定。
## 8.4.2 堆排序
![[Pasted image 20251103171311.png]]
被选出的堆顶元素，就不会再继续参与排序（已确定）
### 代码实现
![[Pasted image 20251103171801.png]]
建堆过程时间复杂度：O(n)，排序整体时间复杂度：O(nlog n)，空间复杂度：O(1)，不稳定
### 堆
![[Pasted image 20251103165446.png]]
逻辑上是一棵顺序存储的完全二叉树，大根堆就是根节点大于左右子树。

将初始的序列建立为一个大根堆，再使用选择排序就能提高效率。
![[Pasted image 20251103170150.png]]
### 堆的代码实现
![[Pasted image 20251103170622.png]]
### 堆插入与删除
![[Pasted image 20251103173416.png]]
![[Pasted image 20251103173627.png]]
# 8.5
## 8.5.1 归并排序
## 8.5.2 基数排序
## 8.5.3 计数排序
# 8.7 
