# 6.1 图的基本概念
![[Pasted image 20251029180546.png]]
图算法的难度较大，主要掌握深度优先搜索与广度优先搜索。掌握图的基本概念及基本性质、图的存储结构（邻接矩阵、邻接表、邻接多重表和十字链表）及其特性、存储结构之间的转化。基于存储结构上的遍历操作和各种应用（拓扑排序、最小生成树、最短路径和关键路径）等。图的相关算法较多通常只要求掌握其基本思想和实现步骤，而算法的具体实现不是重点。
## 6.1.1 图的定义
图G由顶点集V和边集E组成，记为G=(V,E).
其中V(G)表示图G中顶点的有限非空集；E(G)表示图G中顶点之间的关系（边）集合。

线性表可以是空表，树可以是空树，但图**不可以是空图**。就是说，图中不能一个顶。
也没有，图的顶点集V一定非空，但边集召可以为空，此时图中只有顶点而没有边。
### 稠密图与稀疏图
![[Pasted image 20251029182133.png]]
### 有向图
![[Pasted image 20251029180418.png]]
### 无向图
![[Pasted image 20251029180437.png]]
### 简单图、多重图
人话：不存在重复的边与自己链接的环。一般数据结构中仅仅讨论简单图
![[Pasted image 20251029180746.png]]
### 完全图（简单完全图）
人话：各个点之间都有边
![[Pasted image 20251029180928.png]]
### 子图、生成子图
G的一部分边与点构成的图。并非V和E的任何子集都能构成G的子图，因为这样的子集可能不是图，即巨的子集中的某些边关联的顶点可能不在这个V的子集中。

若V(G)=V(G')，子图G‘是G的生成子图
### 路径、路径长度与回路
路径指包括首尾的由边连着的链状的点集。
路径长度是边的个数。
回路指首尾相连。
![[Pasted image 20251029181611.png]]
### 简单路径与简单回路
没有重复的顶点，当然不包括首尾。
### 距离
最短的路径长度。
![[Pasted image 20251029182021.png]]
### 网与权
![[Pasted image 20251029182239.png]]
带权路径长度：一条路径所有边的权的和。
### 连通、连通图与连通分量（针对无向图）
对于n个顶点的G图：
是连通图，至少有n-1条边
非连通图，最多有以n-2为底的C^2
![[Pasted image 20251029181508.png]]
### 强连通图与强连通分量（针对有向图）
有向图强连通情况下边最少的情况：至少需要n条边，构成一个环路。
![[Pasted image 20251029182626.png]]
### 有向树
![[Pasted image 20251029182412.png]]
### 顶点的度、入度与出度
无向图：所有点度的和 = 2 * 边的数量
有向图：入度和 = 出度和 = 边的数量
# 6.2 图的存储形式与基本操作
## 6.2.1 邻接矩阵
将邻接的关系保存在二维数组中。
![[Pasted image 20251029214015.png]]
![[Pasted image 20251029214029.png]]
![[Pasted image 20251029214112.png]]
特点：
- 无向图的邻接矩阵是对称矩阵，对规模特大的邻接矩阵可采用压缩存储。
- 邻接矩阵表示法的空间复杂度为 0(|V|)
-  对于无向图，邻接矩阵的第i行(或第i列)非零元素(或非∞元素)的个数正好是顶点
i 的度 TD(v)。
- ![[Pasted image 20251029214421.png]]
- 用邻接矩阵存储图，很容易确定图中两个顶点之间是否有边相连。但是，要确定图中有多少条边、则必须按行、按列对每个元素进行检测，花费的时间代价很大。
- 稠密图适合使用邻接矩阵的存储表示。
- ![[Pasted image 20251029214507.png]]
## 6.2.2 邻接表
当一个图为稀疏图时，使用邻接矩阵法显然要浪费大量的存储空间，而图的邻接表法结合了顺序存储和链式存储方法，大大减少了这种不必要的浪费。
![[Pasted image 20251029222900.png]]
![[Pasted image 20251029222955.png]]
![[Pasted image 20251029223409.png]]

特点：
- 若 G为无向图，则所需的存储空间为 O(|V|+2|E|)，2是由于无向图中，每条边在邻接表中出现了两次。
- 若 G为有向图，则所需的存储空间为O(|V|+|E|)
- 对于稀疏图，采用邻接表表示将极大地节省存储空间。
- 在邻接表中，能很容易地找出一个顶点的所有邻边。在邻接矩阵中，相同的操作则需要扫描一行，花费的时间为 0(n)。
- 若要确定给定的两个顶点间是否存在边，则在邻接矩阵中可以立刻查到，而在邻接表中则需要在相应结点对应的边表中查找另一结点，效率较低。
- 图的邻接表表示并不唯一，它取决于建立邻接表的算法及边的输入次序。而邻接矩阵是唯一的。
- 在有向图的邻接表表示中，求一个给定顶点的出度只需计算其邻接表中的结点个数;但求其顶点的入度则需要遍历全部的邻接表。
## 6.2.3 十字链表（有向图）
![[Pasted image 20251029223854.png]]
![[Pasted image 20251029223917.png]]
![[Pasted image 20251029224006.png]]
图的十字链表表示是不唯一的，但一个十字链表表示确定一个图。
空间复杂度：O(|V|+|E|)
## 6.2.4 邻接多重表（无向图）
![[Pasted image 20251029224140.png]]
![[Pasted image 20251029224322.png]]
空间复杂度：O(|V|+|E|)

![[Pasted image 20251029224622.png]]
理解，邻接多重表与十字链表，其代码实现较复杂，不会考察代码。
## 6.2.5 图的基本操作
- Adjacent(G,x,y):判断图G是否存在边<x,y>或(x,y)。
![[Pasted image 20251029224831.png]]
# 6.3 图的遍历
## 6.3.1 广度优先搜索
遍历图的过程是以v为起始点，由近至远依次访问和，有路径相通且路径长度为1,2,…的顶点。算法必须借助一个辅助队列，以记忆正在访问的顶点的下一层项点。
![[Pasted image 20251029231005.png]]
**性能分析**：
- 无论是邻接表还是邻接矩阵的存储方式，BFS 算法都需要借助一个辅助队列，在最坏的情况下，空间复杂度为 O(|V|)。
- 邻接表，每个顶点均需搜索一次(或入队一次)，故时间复杂度为 O(|V|)，在搜索任意一个顶点的邻接点时，每条边至少访问一次，故时间复杂度为 O(E)，算法总的时间复杂度为 O(|V|+|E|)。
- 邻接矩阵，査找每个顶点的邻接点所需的时间为 O(|V|)，故算法总的时间复杂度为 O(IV|^2)。
### 广度优先生成树与森林
广度遍历得到一棵遍历树，称为广度优先生成树：
- 邻接矩阵存储表示是唯一的，其广度优先生成树也是唯一的，
- 邻接表存储表示不唯一，广度优先生成树是不唯一的。
广度优先生成树组成的森林就是广度优先生成森林
![[Pasted image 20251029231426.png]]
## 6.3.2 深度优先搜索
