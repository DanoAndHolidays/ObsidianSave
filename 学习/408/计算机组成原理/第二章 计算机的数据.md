# 2.1 数据的表示
## 2.1.1 进位计数制
![[Pasted image 20251112172818.png]]
基数：内个数码位所用到的符号的数量，r进制的基数为r
### 位权展开法（转为十进制）
![[Pasted image 20251112172942.png]]

![[Pasted image 20251112173120.png]]
### 二八十六进制互转
![[Pasted image 20251112173351.png]]

![[Pasted image 20251112173438.png]]
### 除基取余法（十进制转任意进制）
除二倒取余：
![[Pasted image 20251112174326.png]]
### 乘基取整法
乘二正取整：
![[Pasted image 20251112174629.png]]
0.2与0.3无法使用二进制精确的表示，是因为没有2^x的组合能够拼出这两个数，只能无限的接近，一般取到小数点第五位
### 真值与机器数
![[Pasted image 20251112174952.png]]
## 2.1.2 定点数的编码表示
### 无符号数
![[Pasted image 20251112175953.png]]
![[Pasted image 20251112180022.png]]
通常讨论无符号数时，只会讨论整数
### 有符号数
![[Pasted image 20251112180327.png]]
![[Pasted image 20251112183104.png]]
![[Pasted image 20251112182404.png]]
- 原码：
	![[Pasted image 20251112180910.png]]
	
	![[Pasted image 20251112181255.png]]
- 反码：与原码一一对应
	![[Pasted image 20251112181409.png]]
- 补码：
	![[Pasted image 20251112182058.png]]
	由[x]补求[-x]补：符号位与数值为全部取反，末尾再+1
	由补码求原码的快速运算：符号位不变，从右向左找到第一个“1”，将这个“1”左侧剩余的尾数取反，即可得到源码。用尾数取反+1也是一样的
- 移码：可以使用移码的值来比较真值的大小
	![[Pasted image 20251112182235.png]]
## 2.1.2 码的作用
![[Pasted image 20251113164652.png]]
在使用有符号数的原码进行运算的时候（+-），必须要考虑数的正负，否则计算的结果会有异常，我们可以使用模运算将两个数的减法变为加法
### 模运算
![[Pasted image 20251113165627.png]]

由于模运算的性质，实质上是将数分为不同的类，上例中分为12类，而在字长为8bit的计算机中，是将数分为了2^8 类，也就是8位的计算机会自动的进行mod2^8的操作：
![[Pasted image 20251113170453.png]]
补码，也就是原码的补数，通过这样的方式就能仅在ALU中实现加法操作
## 2.1.4 C语言中的类型转换
在计算机中，有符号定点整数通常是使用补码来表示的
![[Pasted image 20251113171927.png]]
### 零扩展与符号扩展
![[Pasted image 20251113172127.png]]

![[Pasted image 20251113173137.png]]
# 2.2 数据的运算
## 2.2.0 电路
优先级：非>与>或，有括号先算括号
![[Pasted image 20251113174907.png]]
### 基本逻辑运算
![[Pasted image 20251113173724.png]]

![[Pasted image 20251113173832.png]]

![[Pasted image 20251113173946.png]]
### 复合逻辑运算
![[Pasted image 20251113174129.png]]

![[Pasted image 20251113174212.png]]

![[Pasted image 20251113174453.png]]

![[Pasted image 20251113174832.png]]
### 多路选择器
![[Pasted image 20251113180449.png]]
### 三态门
![[Pasted image 20251113180552.png]]
## 2.2.1 加法器
### 串行进位的并行加法器
进位信息是串行产生的，只有后一位运算完，前一位才能得到稳定的结果，这也叫行波进位
![[Pasted image 20251113181258.png]]

![[Pasted image 20251113181417.png]]
### 并行进位的并行加法器
![[Pasted image 20251113181810.png]]
无论是串行还是并行，都可以封装为一个加法器，不必关心其内部
### 带有标志位的加法器
![[Pasted image 20251113182101.png]]
![[Pasted image 20251113182551.png]]
### 算数逻辑单元ALU
![[Pasted image 20251113183705.png]]

![[Pasted image 20251113183857.png]]

![[Pasted image 20251113185327.png]]
## 2.2.2 定点数的位移运算
### 逻辑移位（无符号整数）
![[Pasted image 20251113190330.png]]
![[Pasted image 20251113190415.png]]

![[Pasted image 20251113190519.png]]
### 算数移位（带符号整数 补码）
![[Pasted image 20251113190809.png]]
![[Pasted image 20251113190841.png]]

![[Pasted image 20251113191051.png]]
## 2.2.3 定点数的加减运算
![[Pasted image 20251113192650.png]]

这种方式实现很困难，一般使用补码：
![[Pasted image 20251113193326.png]]

只有同号的两个数相加才会溢出，异号的两个数的和只能比这两个数的绝对值更小，不可能溢出：
![[Pasted image 20251113193900.png]]
### 溢出判断
![[Pasted image 20251113194318.png]]

![[Pasted image 20251113194521.png]]

![[Pasted image 20251113194829.png]]
## 2.2.4 无符号数的加减运算
### 回顾带符号数的加减运算
![[Pasted image 20251123161611.png]]
### 无符号数的加法运算
与有符号数的加法运算是一样的：
![[Pasted image 20251123162143.png]]
### 无符号数的减法运算
与有符号数的减法运算是一样的：
![[Pasted image 20251123162427.png]]
### 溢出判断

![[Pasted image 20251123162645.png]]

![[Pasted image 20251123162908.png]]
### 电路实现补码加减运算
参考本章：带有标志位的加法器中的标志位的生成原理
![[Pasted image 20251123163823.png]]

![[Pasted image 20251123164318.png]]
## 2.2.5 无符号与带符号整数乘除法
### 无符号整数乘法
![[Pasted image 20251123165438.png]]

![[Pasted image 20251123165729.png]]

![[Pasted image 20251123170110.png]]
![[Pasted image 20251123170240.png]]
##### 溢出判断
在大部分计算机中，n bit的数相乘依旧为n bit，这就可能会发生溢出
![[Pasted image 20251123170811.png]]
### 带符号数乘法
![[Pasted image 20251123172354.png]]

![[Pasted image 20251123172729.png]]
![[Pasted image 20251123172857.png]]
##### 溢出判断
![[Pasted image 20251123173952.png]]
对于1110 1110 就查看1110 1 这n+1个bit是否完全相同
### 计算机实现乘法的三种方式
![[Pasted image 20251129141037.png]]
##### 两位乘法
每轮（也就是在同样的时钟周期）中处理末尾的2bit，原先使用n个时钟的情况下的乘法，现在可以使用n/2个时钟处理完。
##### 阵列乘法器
使用更多的硬件，就可以减少时钟周期（不需要掌握电路原理）
![[Pasted image 20251129135937.png]]
##### 逻辑运算、加减运算等效实现
可以使用软件的形式实现乘法，不过其速度很慢
![[Pasted image 20251129140234.png]]
### 无符号整数的除法
##### 手算
![[Pasted image 20251129142302.png]]
##### 除法电路
重点关注开始状态、结束状态以及异常，中间细节可以放缓
![[Pasted image 20251129142932.png]]
![[Pasted image 20251129143324.png]]
这里使用的是回复余数法，同时也有不恢复的方式
##### 商溢出
![[Pasted image 20251129154221.png]]
# 2.3 浮点数
在考研中，仅考察IEEE 754的规则，其他规则并不考察。并且考研中，浮点数进关注加减法，不关注乘除法
## 2.3.1 IEEE 754 标准浮点数
![[Pasted image 20251129160505.png]]

由于计算机的机器字长是有限的，对于一个超大数据，我们不可能一直扩展其位数长度，我们可以将其中的一部分舍去（数据精度丢失），以用更少的bit存储，同时对于整体的影响并不太大。
![[Pasted image 20251129161709.png]]

位数的位数决定了表示的数的精度，阶码表示数值表示的范围的大小，在计算机中基数默认是2：
![[Pasted image 20251129161827.png]]
##### float
由于规格化的位数，它一定会有一个1在首位，所以我们隐含的默认它，将这一位用于存储更低位的位数。阶码，表示小数点的向前向后的移动，使用移码存储：
![[Pasted image 20251129162408.png]]
##### double
![[Pasted image 20251129163021.png]]
## 2.3.2 浮点数的表示范围
##### 特殊转态浮点数
![[Pasted image 20251129164324.png]]
##### 表示范围
![[Pasted image 20251129165226.png]]
##### 溢出
![[Pasted image 20251129165652.png]]
![[Pasted image 20251129165950.png]]
	IEEE 规定浮点数溢出不会导致程序的中断

![[Pasted image 20251129165810.png]]

![[Pasted image 20251129170527.png]]

![[Pasted image 20251129170616.png]]

![[Pasted image 20251129171016.png]]

![[Pasted image 20251129171438.png]]

![[Pasted image 20251129172115.png]]

![[Pasted image 20251129172137.png]]
## 2.3.3 数据的存储和排列
这里B站的视频少了几节？
##### 大小端模式
![[Pasted image 20251129172804.png]]
##### 边界对齐
![[Pasted image 20251129173953.png]]
